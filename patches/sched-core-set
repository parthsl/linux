Bottom: b74db24802ab41983c854ec8aa16ed715e976e2d
Top:    2cb8809e445fc38a51cec3e465534d7f1d4a2c2b
Author: Parth Shah <parth@linux.ibm.com>
Date:   2020-05-05 10:20:17 +0530

sched/core: Set nr_lat_sensitive counter at various scheduler entry/exit points

Monitor tasks at:
1. wake_up_new_task (forked tasks will eventually call this)

2. set_task_cpu (sched_exec eventually calls this)

3. __sched_setscheduler (set/unset latency_nice value)
Increment the nr_lat_sensitive count on the CPU with task marked with
latency_nice == -20.
Similarly, decrement the nr_lat_sensitive counter upon re-marking the task
with >-20 latency_nice task.

4. finish_task_switch (dying task)

Signed-off-by: Parth Shah <parth@linux.ibm.com>

---

diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 4ec4cef13088..f74c307e56c1 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -1744,6 +1744,13 @@ void set_task_cpu(struct task_struct *p, unsigned int new_cpu)
 	trace_sched_migrate_task(p, new_cpu);
 
 	if (task_cpu(p) != new_cpu) {
+		if (task_is_lat_sensitive(p)) {
+			task_lock(p);
+			atomic_dec(&per_cpu(nr_lat_sensitive, task_cpu(p)));
+			atomic_inc(&per_cpu(nr_lat_sensitive, new_cpu));
+			task_unlock(p);
+		}
+
 		if (p->sched_class->migrate_task_rq)
 			p->sched_class->migrate_task_rq(p, new_cpu);
 		p->se.nr_migrations++;
@@ -2947,6 +2954,7 @@ void wake_up_new_task(struct task_struct *p)
 {
 	struct rq_flags rf;
 	struct rq *rq;
+	int target_cpu = 0;
 
 	raw_spin_lock_irqsave(&p->pi_lock, rf.flags);
 	p->state = TASK_RUNNING;
@@ -2960,9 +2968,20 @@ void wake_up_new_task(struct task_struct *p)
 	 * as we're not fully set-up yet.
 	 */
 	p->recent_used_cpu = task_cpu(p);
-	__set_task_cpu(p, select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0));
+	target_cpu = select_task_rq(p, task_cpu(p), SD_BALANCE_FORK, 0);
+	__set_task_cpu(p, target_cpu);
+
 #endif
 	rq = __task_rq_lock(p, &rf);
+
+#ifdef CONFIG_SMP
+	if (task_is_lat_sensitive(p)) {
+		task_lock(p);
+		atomic_inc(&per_cpu(nr_lat_sensitive, target_cpu));
+		task_unlock(p);
+	}
+#endif
+
 	update_rq_clock(rq);
 	post_init_entity_util_avg(p);
 
@@ -3248,6 +3267,12 @@ static struct rq *finish_task_switch(struct task_struct *prev)
 		if (prev->sched_class->task_dead)
 			prev->sched_class->task_dead(prev);
 
+		if (task_is_lat_sensitive(prev)) {
+			task_lock(prev);
+			atomic_dec(&per_cpu(nr_lat_sensitive, prev->cpu));
+			task_unlock(prev);
+		}
+
 		/*
 		 * Remove function-return probe instances associated with this
 		 * task and put them back on the free list.
@@ -4732,8 +4757,19 @@ static void __setscheduler_params(struct task_struct *p,
 	p->normal_prio = normal_prio(p);
 	set_load_weight(p, true);
 
-	if (attr->sched_flags & SCHED_FLAG_LATENCY_NICE)
+	if (attr->sched_flags & SCHED_FLAG_LATENCY_NICE) {
+		task_lock(p);
+		if (p->state != TASK_DEAD &&
+		    attr->sched_latency_nice != p->latency_nice) {
+			if (attr->sched_latency_nice == MIN_LATENCY_NICE)
+				atomic_inc(&per_cpu(nr_lat_sensitive, task_cpu(p)));
+			else if (task_is_lat_sensitive(p))
+				atomic_dec(&per_cpu(nr_lat_sensitive, task_cpu(p)));
+		}
+
 		p->latency_nice = attr->sched_latency_nice;
+		task_unlock(p);
+	}
 }
 
 /* Actually do priority change: must hold pi & rq lock. */
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index 540860584502..edc0cda8b90e 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -211,6 +211,11 @@ static inline int task_has_dl_policy(struct task_struct *p)
 	return dl_policy(p->policy);
 }
 
+static inline int task_is_lat_sensitive(struct task_struct *p)
+{
+	return p->latency_nice == MIN_LATENCY_NICE;
+}
+
 #define cap_scale(v, s) ((v)*(s) >> SCHED_CAPACITY_SHIFT)
 
 /*
